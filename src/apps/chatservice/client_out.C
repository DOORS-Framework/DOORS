
/* Example implementation of outbox. Just the basics, nothing fancy.
 * Reads the receiver name and message from input. You can send to
 * many receivers at once by giving a comma/space separated list of
 * names(eg. "MrA,MrB  MsC  ,   MrD MsE"). To end program, just hit
 * ^C or ^D. client_in should be running before attempting to start
 * client_out(outbox).
 */


#include <fstream>
#include <cstdlib>
#include <iostream>

#include "cosnaming.h"
#include "CMB.h"
#include <doors/slpwrap.h>


const std::string ns_name = "namingservice";
const std::string broker_name = "CorbaMessageBroker";
const std::string broker_kind = "cn";
 
// Reads the "Key" from the file generated by client_in(Inbox).
CORBA::ULong TaioAvain(void)
{
    std::ifstream inFile( "doors.key" );

    if( !inFile )
	return 0;

    std::string key;
    inFile >> key;

    inFile.close();
    return atoi(key.c_str());
}

// Reads the name of the user from the file generated by client_in(Inbox).
std::string TaioNimi(void)
{
    std::ifstream inFile( "doors.key" );

    if( !inFile )
	return 0;

    std::string nimi;
    inFile >> nimi;
    inFile >> nimi;

    inFile.close();
    return nimi;
}

// Reads a line from standard input.
void GetLine( std::string &msg )
{
    char ch;
//    cin.get(ch);
    //  getline(cin, msg);
    std::cin >> msg;
    std::cout << "GetLine():" << msg << std::endl;
}


int main( int argc, char *argv[] )
{
    // The usual corba stuff.
    CORBA::ORB_var orb = CORBA::ORB_init( argc, argv, "mico-local-orb" );
    CORBA::Object_var poaobj = orb->resolve_initial_references ("RootPOA");
    PortableServer::POA_var poa = PortableServer::POA::_narrow (poaobj);
    PortableServer::POAManager_var mgr = poa->the_POAManager();

    std::cout << "Client_out starting" << std::endl;

    // Handle to the namingservice
    CORBA::Object_var namingserver;

    std::cout << "Resolving NS address" << std::endl;
    CORBA::String_var str_ior = CORBA::string_dup(FindIORwithSLP(ns_name).c_str());

    assert(strcmp((char*)str_ior, ""));

    namingserver = orb->string_to_object(str_ior);

    
    CosNaming::NamingContext_ptr ns=CosNaming::NamingContext::_narrow(namingserver);

    // Get a handle to the Corba Message Broker.
    CosNaming::Name name;
    name.length (4);
    name[0].id = "FourthFloor";
    name[0].kind = "ou";
    name[1].id = "Telecommunications";
    name[1].kind = "ou";
    name[2].id = "HC414";
    name[2].kind = "ou";
    name[3].id = broker_name.c_str();
    name[3].kind = broker_kind.c_str();


    std::cout << "Resolving Broker address" << std::endl;
    CORBA::Object_ptr obj = ns->resolve(name);

    CMB::Broker_ptr broker = CMB::Broker::_narrow(obj);


    // Get the magic key and name
    CORBA::ULong key = TaioAvain();
    std::string me = TaioNimi();

    // Ready for mainloop
    bool P=true;
    std::string kohde = "all";
    std::string msg = "";

    while(P) // Enter The Loop
    {
	std::cout << "Person" << "[" << kohde << "]: ";
	std::cout.flush();

	// Get recipient name, if none given, use old one.
	std::string temp_kohde;
	GetLine(temp_kohde);
	if(temp_kohde != "")
	    kohde = temp_kohde;

	// Read the message from cin.
	std::cout << "Message: ";
	std::cout.flush();
	msg="";
	GetLine(msg);

	// If ^D given or end of input from file perhaps
	if(!std::cin)
	    P=false;

	// If still in loop and sending succeeds, give feedback
	if(P && broker->SendMessage(kohde.c_str(),me.c_str(),key,msg.c_str()))
	    std::cout << "Message sent!" << std::endl;
	else if(P)
	    std::cout << "Message not sent!" << std::endl;
    }

    std::cout << "Closing outbox" << std::endl;


    poa->destroy(true, true);

    // Free memory
    delete broker;
    delete obj;
    delete ns;

    return 0;
}
